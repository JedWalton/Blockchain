type: edu
custom_name: stage6
files:
- name: test/BlockchainTest.java
  visible: false
  text: |
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testcase.TestCase;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.stream.Collectors;


    class BlockParseException extends Exception {
        BlockParseException(String msg) {
            super(msg);
        }
    }


    class Block {

        int id;
        long timestamp;
        long magic;
        String hashprev;
        String hash;

        static Block parseBlock(String strBlock) throws BlockParseException {
            if (strBlock.length() == 0) {
                return null;
            }

            if (!(strBlock.contains("Block:")
                && strBlock.contains("Timestamp:"))) {

                return null;
            }

            Block block = new Block();

            List<String> lines = strBlock
                .lines()
                .map(String::strip)
                .filter(e -> e.length() > 0)
                .collect(Collectors.toList());

            if (lines.size() < 13) {
                throw new BlockParseException("Every block should " +
                    "contain at least 13 lines of data");
            }

            if (!lines.get(0).equals("Block:")) {
                throw new BlockParseException("First line of every block " +
                    "should be \"Block:\"");
            }

            if (!lines.get(1).startsWith("Created by")) {
                throw new BlockParseException("Second line of every block " +
                    "should start with \"Created by\"");
            }

            if (!lines.get(2).contains("gets 100 VC")) {
                throw new BlockParseException("Third line of every block " +
                    "should contain \"gets 100 VC\"");
            }

            if (!lines.get(3).startsWith("Id:")) {
                throw new BlockParseException("4-th line of every block " +
                    "should start with \"Id:\"");
            }

            String id = lines.get(3).split(":")[1]
                .strip().replace("-", "");
            boolean isNumeric = id.chars().allMatch(Character::isDigit);

            if (!isNumeric) {
                throw new BlockParseException("Id should be a number");
            }

            block.id = Integer.parseInt(id);



            if (!lines.get(4).startsWith("Timestamp:")) {
                throw new BlockParseException("5-th line of every block " +
                    "should start with \"Timestamp:\"");
            }

            String timestamp = lines.get(4).split(":")[1]
                .strip().replace("-", "");
            isNumeric = timestamp.chars().allMatch(Character::isDigit);

            if (!isNumeric) {
                throw new BlockParseException("Timestamp should be a number");
            }

            block.timestamp = Long.parseLong(timestamp);


            if (!lines.get(5).startsWith("Magic number:")) {
                throw new BlockParseException("6-th line of every block " +
                    "should start with \"Magic number:\"");
            }

            String magic = lines.get(5).split(":")[1]
                .strip().replace("-", "");
            isNumeric = magic.chars().allMatch(Character::isDigit);

            if (!isNumeric) {
                throw new BlockParseException("Magic number should be a number");
            }

            block.magic = Long.parseLong(magic);



            if (!lines.get(6).equals("Hash of the previous block:")) {
                throw new BlockParseException("7-th line of every block " +
                    "should be \"Hash of the previous block:\"");
            }

            if (!lines.get(8).equals("Hash of the block:")) {
                throw new BlockParseException("9-th line of every block " +
                    "should be \"Hash of the block:\"");
            }

            String prevhash = lines.get(7).strip();
            String hash = lines.get(9).strip();

            if (!(prevhash.length() == 64 || prevhash.equals("0"))
                || !(hash.length() == 64)) {

                throw new BlockParseException("Hash length should " +
                    "be equal to 64 except \"0\"");
            }

            block.hash = hash;
            block.hashprev = prevhash;

            if (!lines.get(10).startsWith("Block data:")) {
                throw new BlockParseException("11-th line of every block " +
                    "should start with \"Block data:\"");
            }

            return block;
        }


        static List<Block> parseBlocks(String output) throws BlockParseException {
            String[] strBlocks = output.split("\n\n");

            List<Block> blocks = new ArrayList<>();

            for (String strBlock : strBlocks) {
                Block block = parseBlock(strBlock.strip());
                if (block != null) {
                    blocks.add(block);
                }
            }

            return blocks;
        }
    }

    class Clue {
        String zeros;
        Clue(int n) {
            zeros = "0".repeat(n);
        }
    }


    public class BlockchainTest extends StageTest<Clue> {

        List<String> previousOutputs = new ArrayList<>();

        @Override
        public List<TestCase<Clue>> generate() {
            return List.of(
                new TestCase<>(),
                new TestCase<>()
            );
        }

        @Override
        public CheckResult check(String reply, Clue clue) {

            if (previousOutputs.contains(reply)) {
                return new CheckResult(false,
                    "You already printed this text in the previous tests");
            }

            previousOutputs.add(reply);

            List<Block> blocks;
            try {
                blocks = Block.parseBlocks(reply);
            } catch (BlockParseException ex) {
                return new CheckResult(false, ex.getMessage());
            } catch (Exception ex) {
                return CheckResult.wrong("");
            }

            if (blocks.size() != 15) {
                return new CheckResult(false,
                    "In this stage you should output 15 blocks, found " + blocks.size());
            }

            for (int i = 1; i < blocks.size(); i++) {
                Block curr = blocks.get(i - 1);
                Block next = blocks.get(i);

                if (curr.id + 1 != next.id) {
                    return new CheckResult(false,
                        "Id`s of blocks should increase by 1");
                }

                if (next.timestamp < curr.timestamp) {
                    return new CheckResult(false,
                        "Timestamp`s of blocks should increase");
                }

                if (!next.hashprev.equals(curr.hash)) {
                    return new CheckResult(false, "Two hashes aren't equal, " +
                        "but should");
                }
            }


            return CheckResult.correct();
        }
    }
  learner_created: false
- name: test/blockchain/MainTest.java
  visible: true
  text: |-
    package blockchain;

    import junit.framework.TestCase;
    import org.junit.Test;

    public class MainTest extends TestCase {
        @Test
        public void testPrintMessage() {
            assertEquals("test", "test");
        }
    }
  learner_created: false
- name: test/blockchain/BlockchainTest.java
  visible: true
  text: |-
    package blockchain;

    import junit.framework.TestCase;
    import org.junit.Test;

    public class BlockchainTest extends TestCase {

        @Test
        public void testPrintMessage() {
            assertEquals("hi", "hi");
        }

    }
  learner_created: false
- name: src/blockchain/Main.java
  visible: true
  learner_created: true
- name: src/blockchain/Blockchain.java
  visible: true
  learner_created: true
- name: src/blockchain/Block.java
  visible: true
  learner_created: true
- name: src/blockchain/Miner.java
  visible: true
  learner_created: true
- name: src/blockchain/BotUser.java
  visible: true
  text: |-
    package blockchain;

    import java.security.*;
    import java.time.LocalDateTime;
    import java.util.HashMap;
    import java.util.Map;

    public class BotUser {

        private static final Map<String, BotUser> users = new HashMap<>();

        private final String name;
        private final Blockchain blockchain;
        private PrivateKey privateKey;
        private PublicKey publicKey;

        private BotUser(String name) {
            this.name = name;
            this.blockchain = Blockchain.getInstance();
            users.put(name, this);
            createKeyPair();
        }

        public static BotUser getBotUser(String name) {
            return users.getOrDefault(name, new BotUser(name));
        }

        public String getName() {
            return name;
        }

        public PublicKey getPublicKey() {
            return publicKey;
        }

        public void createKeyPair() {
            try {
                KeyPair keyPair = KeyPairCreator.createKeyPair();
                privateKey = keyPair.getPrivate();
                publicKey = keyPair.getPublic();
            } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
                e.printStackTrace();
            }
        }

        public void sendMessage(String textMessage) {
            byte[] signature;
            try {
                LocalDateTime dateTime = LocalDateTime.now();
                long id = blockchain.getNewDataId();
                signature = signMessage(name + textMessage + dateTime.toString() + id);
                Message message = new Message(name, textMessage, dateTime, id, signature, publicKey);
                blockchain.addMessage(message);
            } catch (NoSuchAlgorithmException | InvalidKeyException | SignatureException e) {
                e.printStackTrace();
            }
        }

        private byte[] signMessage(String data) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
            Signature rsa = Signature.getInstance("SHA1withRSA");
            rsa.initSign(privateKey);
            rsa.update(data.getBytes());
            return rsa.sign();
        }
    }
  learner_created: true
- name: src/blockchain/KeyPairCreator.java
  visible: true
  text: |-
    package blockchain;

    import java.security.*;

    public class KeyPairCreator {
        public static KeyPair createKeyPair() throws NoSuchAlgorithmException, NoSuchProviderException {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");

            SecureRandom random = SecureRandom.getInstance("SHA1PRNG", "SUN");
            keyGen.initialize(1024, random);

            return keyGen.generateKeyPair();
        }
    }
  learner_created: true
- name: src/blockchain/BlockchainValidator.java
  visible: true
  text: |-
    package blockchain;

    import java.util.List;
    import java.util.Objects;
    import java.util.OptionalLong;

    public class BlockchainValidator {

        public static boolean isBlockchainValid() {
            Blockchain blockchain = Blockchain.getInstance();
            List<Block> blocks = blockchain.getBlocks();

            if (isBlockchainEmpty()) {
                return true;
            }
            if (!isFirstBlockValid(blocks.get(0))) {
                return false;
            }
            for (int i = 1; i < blocks.size(); i++) {
                if (hasWrongPreviousHash(blocks.get(i), blocks.get(i - 1))) {
                    return false;
                }
                if (hasOneOfTheMessagesAnInvalidId(blocks.get(i), i - 1)) {
                    return false;
                }
                if (hasOneOfTheMessagesAnInvalidSignature(blocks.get(i))) {
                    return false;
                }
            }
            return true;
        }

        public static boolean isNewBlockValid(Block block) {
            if (isBlockchainEmpty()) {
                return isFirstBlockValid(block);
            }
            Block lastBlock = Blockchain.getInstance().getLastBlock();
            if (hasWrongPreviousHash(block, lastBlock)) {
                return false;
            }
            int indexOfLastBlock = Blockchain.getInstance().getNbOfBlocks() - 1;
            if (hasOneOfTheMessagesAnInvalidId(block, indexOfLastBlock)) {
                return false;
            }
            if (hasOneOfTheMessagesAnInvalidSignature(block)) {
                return false;
            }
            if (hasWrongNumberOfZerosInHash(block)) {
                return false;
            }
            return true;
        }

        private static boolean isBlockchainEmpty() {
            List<Block> blocks = Blockchain.getInstance().getBlocks();
            return blocks.size() == 0;
        }

        private static boolean isFirstBlockValid(Block block) {
            return "0".equals(block.getHashOfPreviousBlock());
        }

        private static boolean hasOneOfTheMessagesAnInvalidId(Block block, int indexOfPreviousBlock) {
            if (indexOfPreviousBlock == 0) {
                return false;
            }
            List<Block> blocks = Blockchain.getInstance().getBlocks();
            OptionalLong previousBlockMax = blocks.get(indexOfPreviousBlock).getMessages().stream()
                    .map(Message::getId)
                    .mapToLong(l -> l)
                    .max();
            if (previousBlockMax.isPresent()) {
                return block.getMessages().stream()
                        .anyMatch(message -> message.getId() <= previousBlockMax.getAsLong());
            }
            // Recursive check of another block up the chain if there was no message in the previous one.
            return hasOneOfTheMessagesAnInvalidId(block, indexOfPreviousBlock - 1);
        }

        private static boolean hasWrongPreviousHash(Block block, Block previousBlock) {
            return !Objects.equals(previousBlock.getHash(), block.getHashOfPreviousBlock());
        }

        private static boolean hasOneOfTheMessagesAnInvalidSignature(Block block) {
            return block.getMessages().stream()
                    .anyMatch(message -> !SignatureChecker.check(message));
        }

        private static boolean hasWrongNumberOfZerosInHash(Block block) {
            long nbOfZeros = Blockchain.getInstance().getNbOfZeros();
            String pattern = String.format("0{%s}.*", nbOfZeros);
            return !block.getHash().matches(pattern);
        }

    }
  learner_created: true
- name: src/blockchain/SerializationUtils.java
  visible: true
  text: |-
    package blockchain;

    import java.io.*;

    class SerializationUtils {
        /**
         * Serialize the given object to the file
         */
        public static void serialize(Object obj, String fileName) throws IOException {
            FileOutputStream fos = new FileOutputStream(fileName);
            BufferedOutputStream bos = new BufferedOutputStream(fos);
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(obj);
            oos.close();
        }

        /**
         * Deserialize to an object from the file
         */
        public static Object deserialize(String fileName) throws IOException, ClassNotFoundException {
            FileInputStream fis = new FileInputStream(fileName);
            BufferedInputStream bis = new BufferedInputStream(fis);
            ObjectInputStream ois = new ObjectInputStream(bis);
            Object obj = ois.readObject();
            ois.close();
            return obj;
        }
    }
  learner_created: true
- name: src/blockchain/SignatureChecker.java
  visible: true
  text: |-
    package blockchain;

    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;
    import java.security.Signature;
    import java.security.SignatureException;

    public class SignatureChecker {

        public static boolean check(Message message) {
            Signature signature;
            try {
                signature = Signature.getInstance("SHA1withRSA");
                signature.initVerify(message.getPublicKey());
                String data = message.getSender() + message.getTextMessage() + message.getDateTime().toString() + message.getId();
                signature.update(data.getBytes());
                return signature.verify(message.getSignature());
            } catch (NoSuchAlgorithmException | InvalidKeyException | SignatureException e) {
                e.printStackTrace();
            }
            return false;
        }
    }
  learner_created: true
- name: src/blockchain/HashCreator.java
  visible: true
  text: |
    package blockchain;

    import java.util.List;
    import java.util.stream.Collectors;

    public class HashCreator {

        public static String createHash(
                String hashOfPreviousBlock,
                int id,
                long timestamp,
                int magicNumber,
                List<Message> messages,
                String minerId
        ) {
            String strMessages = messages.stream()
                    .map(Object::toString)
                    .collect(Collectors.joining("\n"));
            String data = hashOfPreviousBlock + id + timestamp + strMessages + minerId + magicNumber;
            return StringUtil.applySha256(data);
        }
    }
  learner_created: true
- name: src/blockchain/MessageSender.java
  visible: true
  text: |-
    package blockchain;

    import java.util.List;
    import java.util.Map;
    import java.util.Random;
    import java.util.concurrent.TimeUnit;

    public class MessageSender implements Runnable {
        private final List<Map.Entry<String, String>> textMessages = List.of(
                Map.entry("Tom", "Hey, I'm first!"),
                Map.entry("Sarah", "It's not fair!"),
                Map.entry("Sarah", "You always will be first because it is your blockchain!"),
                Map.entry("Sarah", "Anyway, thank you for this amazing chat."),
                Map.entry("Tom", "You're welcome :)"),
                Map.entry("Nick", "Hey Tom, nice chat"),
                Map.entry("Nick", "How did you do that?"),
                Map.entry("Tom", "Well, I asked Vladimir"),
                Map.entry("Tom", "You know him, right?"),
                Map.entry("Sarah", "Blah blah blah"),
                Map.entry("Nick", "Really? Oh wow"),
                Map.entry("Tom", "Yeah and blah blah blah...")
        );

        @Override
        public void run() {
            Random rand = new Random();
            textMessages.forEach(
                    message -> {
                        try {
                            TimeUnit.SECONDS.sleep(rand.nextInt(4));
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        BotUser.getBotUser(message.getKey())
                                .sendMessage(message.getValue());
                    }
            );
        }
    }
  learner_created: true
- name: src/blockchain/StringUtil.java
  visible: true
  text: |-
    package blockchain;

    import java.nio.charset.StandardCharsets;
    import java.security.MessageDigest;

    class StringUtil {
        /* Applies Sha256 to a string and returns a hash. */
        public static String applySha256(String input){
            try {
                MessageDigest digest = MessageDigest.getInstance("SHA-256");
                /* Applies sha256 to our input */
                byte[] hash = digest.digest(input.getBytes(StandardCharsets.UTF_8));
                StringBuilder hexString = new StringBuilder();
                for (byte elem: hash) {
                    String hex = Integer.toHexString(0xff & elem);
                    if(hex.length() == 1) hexString.append('0');
                    hexString.append(hex);
                }
                return hexString.toString();
            }
            catch(Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
  learner_created: true
- name: src/blockchain/BlockchainManager.java
  visible: true
  text: |-
    package blockchain;

    import java.util.ArrayList;
    import java.util.List;

    public class BlockchainManager {

        Blockchain blockchain;

        public BlockchainManager(Blockchain blockchain) {
            this.blockchain = blockchain;
        }

        public void startBlockchain(int nbOfThreads, int nbOfBlocksToAdd) {

            int totalNbOfBlocks = nbOfBlocksToAdd + blockchain.getNbOfBlocks();

            List<Thread> threads = new ArrayList<>(nbOfThreads);

            for (int i = 0; i < nbOfThreads; i++) {
                threads.add(new Thread(
                        new Miner(blockchain, totalNbOfBlocks),
                        "#" + (i + 1)
                ));
                threads.get(i).start();
            }

            startMessageSender();

            for (Thread thread : threads) {
                try {
                    thread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        }

        private void startMessageSender() {
            MessageSender messageSender = new MessageSender();
            Thread messageThread = new Thread(messageSender);
            messageThread.start();
        }

        public static Blockchain retrieveOrCreateBlockchain(String fileName) {
            Blockchain blockchain;

            try {
                blockchain = (Blockchain) SerializationUtils.deserialize(fileName);
                System.out.println("Retrieving existing Blockchain");
            } catch (Exception e) {
                System.out.println(e.getMessage());
                System.out.println("Creating new Blockchain");
                blockchain = Blockchain.getInstance();
            }

            if (!BlockchainValidator.isBlockchainValid()) {
                System.out.println("Invalid blockchain! Creating new one");
                blockchain = Blockchain.getInstance();
            }

            return blockchain;
        }

    }
  learner_created: true
- name: src/blockchain/Message.java
  visible: true
  text: |-
    package blockchain;

    import java.io.Serializable;
    import java.security.PublicKey;
    import java.time.LocalDateTime;

    public class Message implements Serializable {

        private static final long serialVersionUID = 12L;

        private final String sender;
        private final String textMessage;
        private final LocalDateTime dateTime;
        private final long id;
        private final byte[] signature;
        private final PublicKey publicKey;

        public Message(String sender, String textMessage, LocalDateTime dateTime,
                       long id, byte[] signature, PublicKey publicKey) {
            this.sender = sender;
            this.textMessage = textMessage;
            this.dateTime = dateTime;
            this.id = id;
            this.signature = signature;
            this.publicKey = publicKey;
        }

        public byte[] getSignature() {
            return signature;
        }

        public PublicKey getPublicKey() {
            return publicKey;
        }

        public String getTextMessage() {
            return textMessage;
        }

        public LocalDateTime getDateTime() {
            return dateTime;
        }

        public String getSender() {
            return sender;
        }

        public long getId() {
            return id;
        }

        @Override
        public String toString() {
            return String.format("%s: %s", sender, textMessage);
        }
    }
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/5418#comment
status: Failed
feedback:
  message: "Error in test #1\n\nIn this test, the program is running for a long time,\
    \ more than 15 seconds. Most likely, the program has gone into an infinite loop.\n\
    \nPlease find below the output of your program during this failed test.\n\n---\n\
    \nBlock:\nCreated by miner # 1\nminer1 gets 100 VC\nId: 1\nTimestamp: 11989925829710\n\
    Magic number: 224011744581899707\nHash of the previous block:\n0\nHash of the\
    \ block:\n23a932cdcd3f5726a10a067960afcaeb4a863ff267aa3cfc7cd3706e3ac0b744\nBlock\
    \ data: \nNo transactions\nBlock was generating for 0 seconds\nN was increased\
    \ to 2\n\nBlock:\nCreated by miner # 3\nminer3 gets 100 VC\nId: 2\nTimestamp:\
    \ 11989951805295\nMagic number: 8507550953913682281\nHash of the previous block:\n\
    23a932cdcd3f5726a10a067960afcaeb4a863ff267aa3cfc7cd3706e3ac0b744\nHash of the\
    \ block:\n005c73f49656c3d67af934df1082735aac9076153f64c78c3745780b6487f69e\nBlock\
    \ data: \nNo transactions\nBlock was generating for 0 seconds\nN was increased\
    \ to 4\n\nBlock:\nCreated by miner # 14\nminer14 gets 100 VC\nId: 3\nTimestamp:\
    \ 11990066571664\nMagic number: 6395704386184595149\nHash of the previous block:\n\
    005c73f49656c3d67af934df1082735aac9076153f64c78c3745780b6487f69e\nHash of the\
    \ block:\n0000ed2b89b14cb0cfde953da34948f96531d671f06491428d55209f8f7657ef\nBlock\
    \ data: \nNo transactions\nBlock was generating for 0 seconds\nN was increased\
    \ to 5\n\nBlock:\nCreated by miner # 14\nminer14 gets 100 VC\nId: 4\nTimestamp:\
    \ 11990126682563\nMagic number: 3143342609177637558\nHash of the previous block:\n\
    0000ed2b89b14cb0cfde953da34948f96531d671f06491428d55209f8f7657ef\nHash of the\
    \ block:\n000004ff9af1b416f2a07922d5f84f8ac60e2da255a5e68736530499c49ff7ed\nBlock\
    \ data: \n#1 boss24&#39;s money: 100\nboss24 send 30 VC TO employee21\n#2 boss24&#39;s\
    \ money: 70\nboss24 send 30 VC TO employee23\n#3 boss24&#39;s money: 40\nboss24\
    \ send 30 VC TO employee22\n#4 boss28&#39;s money: 100\nboss28 send 31 VC TO employee25\n\
    #5 boss28&#39;s money: 69\nboss28 send 31 VC TO employee27\n#6 boss28&#39;s money:\
    \ 38\nboss28 send 31 VC TO employee26\n#7 boss32&#39;s money: 100\nboss32 send\
    \ 30 VC TO employee29\n#8 boss32&#39;s money: 70\nboss32 send 30 VC TO employee31\n\
    #9 boss32&#39;s money: 40\nboss32 send 30 VC TO employee30\n#10 boss36&#39;s money:\
    \ 100\nboss36 send 31 VC TO employee33\n#11 boss36&#39;s money: 69\nboss36 send\
    \ 31 VC TO employee35\n#12 boss36&#39;s money: 38\nboss36 send 31 VC TO employee34\n\
    #13 boss40&#39;s money: 100\nboss40 send 30 VC TO employee37\n#14 boss40&#39;s\
    \ money: 70\nboss40 send 30 VC TO employee39\n#15 boss40&#39;s money: 40\nboss40\
    \ send 30 VC TO employee38\n#16 miner2&#39;s money: 100\nminer2 send 33 VC TO\
    \ boss24\n#17 boss24&#39;s money: 43\nboss24 send 30 VC TO employee21\n#18 employee21&#39;s\
    \ money: 160\nemployee21 send 26 VC TO boss40\n#19 boss40&#39;s money: 36\nboss40\
    \ send 30 VC TO employee37\n#20 employee31&#39;s money: 130\nemployee31 send 27\
    \ VC TO boss36\n#21 employee29&#39;s money: 130\nemployee29 send 30 VC TO boss24\n\
    #22 boss36&#39;s money: 34\nboss36 send 31 VC TO employee33\n#23 boss24&#39;s\
    \ money: 43\nboss24 send 30 VC TO employee21\n#24 employee21&#39;s money: 164\n\
    employee21 send 26 VC TO boss40\n#25 employee22&#39;s money: 130\nemployee22 send\
    \ 31 VC TO boss32\n#26 boss32&#39;s money: 41\nboss32 send 30 VC TO employee29\n\
    #27 boss40&#39;s money: 32\nboss40 send 30 VC TO employee37\n#28 employee31&#39;s\
    \ money: 103\nemployee31 send 31 VC TO boss24\nBlock was generating for 0 seconds\n\
    N was increased to 6"
  time: Sun, 27 Feb 2022 17:46:12 UTC
record: 6
